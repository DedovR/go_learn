Системный дизайн – это процесс проектирования систем с учетом всех их компонентов и взаимодействий. Он охватывает проектирование архитектуры системы, выбор технологий и методов реализации, а также учет потребностей пользователей и бизнес-цели. Синонимом системного дизайна можно назвать системное проектирование.

## Основные принципы системного дизайна

Системный дизайн не ограничивается выбором технологий или инструментов. Он включает в себя несколько важнейших принципов, которые помогут создать качественную систему.

- Масштабируемость. Способность системы эффективно работать при увеличении нагрузки, как вертикально (добавление мощности к отдельным компонентам), так и горизонтально (добавление новых узлов в систему).
- Отказоустойчивость. Способность системы продолжать работу в случае выхода из строя одного из компонентов.
- Производительность. Система должна обеспечивать высокую скорость работы при минимальных задержках.
- Модульность. Разделение системы на независимые и функционально завершенные части.
- Безопасность. Защита данных и компонентов системы от внешних угроз.
- Надежность. Минимизация сбоев и ошибок в работе системы.
- Гибкость. Возможность адаптации системы к изменениям в требованиях или условиях эксплуатации.
- Согласованность и целостность данных. Предотвращение несоответствий в данных между различными компонентами системы.

## CAP-теорема

Теорема гласит, что невозможно обеспечить выполнение сразу трех принципов проектирования систем:
- Согласованнсоть(Consistency) - фундаментальный принцип при котором все копии данных системы буду одинаковы в любой момент времени.
- Доступность(Availability) - способность системы отвечать на запросы пользователей даже при наличии боев и неполадок системы
- Устойчивость к разделению(Partition Tolerance) - способность системы продолжать работать при потере связи между отельными компонентами

#### Принцип согласованности

В CAP-теорема поднимает важный вопрос: как система может гарантировать, что данные будут согласованно несмотря на распределение и параллельную обработку.
В распределенных системах, есть несколько уровней согласованности, которые имют свои особенности и компромиссы. Среди них:

- **Строгая согласованность**. Требует чтобы все операции чтения и записи происходили в строгом порядке. Это гарантирует, что всем узлам будут видны результаты операции, но иммет задержки на ожидание согласованности.
- **Последовательная согласованность**. Поддерживает порядок операций в рамках каждого клиента, но не гарантирует строгую последовательность между всеми узлами.
- **Причинная согласованность**. Операции видны в порядке в котором они были вызваны, что позволяет соблюдать логический порядок, но не гарантировать строгую последовательность в реальном времени

#### Принцип доступности

Способность системы поддерживать работоспособность даже в условиях сбоев и большой нагрузки. Обеспечение высокой доступности это применение разных подходов и методов, таких как:

- Репликация. Это процесс создания копий данных на разных узлах системы, который позволяет обеспечить доступ к данным в случае отказа одного(нескольких) из узлов.
- Шардирование. Это метод разбиения данных на сегменты(шарды) и распределение их по разным узлам. Каждый узел отвечает за разный набор данных, что позволяет более эффективно распределять нагрузку. Однако есть сложность если требуются данный с разных шардов.

#### Принцип устойчивости

Подразумевает, что система продолжает работу даже есть узлы прекращают обмен данными между собой. Основным механизмом для поддержания усточивости к разделению являетя **кворум**.

**Кворум** - это минимальное количество узлов, которые должны согласиться на выполнение операции. Например в системе из 5 узлов кворум будет равен 3. Кворум обеспечивает баланс между устойчивостью и согласованностью: система продолжает функционировать, даже есть часть узлов вышла из строя и при этом гарантируется что оперции будут согласованы.

### CAP-теорема в разработке

Как правильно выбрать баланс:
- Анализ требований проекта. Нужно понять характер разрабатываемой системы. Например для финансовых систем согласованность будут иметь критическое значение, в то время как доступность будет иметь меньшее значени
- Оценка последствий. Нужно продумать последствия, связанные с выбором одного из принципов. Потеря согласованности может привести к непредсказыемым последствиям для бизнеса, а доступности к репутационным потерям
- Коммуникация с заказчиком. Вовлечение заказчика может помочь определиться с приоритетом

## На интервью

Нужно понимать, что за 45минут-час фичи не проектируются. На интервью нужно показать умение рассуждать, уточнять требования, считать примерную нагрузку, предлогать технологии в зависимости от требований

Всё интервью можно примерно разделить на этапы

### Функциональные требования(~4 минуты)

Нужно узнать требования у интервьеера: что дизайним а что не дизайним. Например для соц.сетей нужно ли дизайнить авторизацию, профиль и т.д. или остановиться на конкретных компонентах, тех которые отличают соцсеть от других систем: лента новостей, посты, файлы.

Лучше всего выписать все требования, определить главные, те которые можно опустить(зачеркнуть но не удалять) и те которые можно задизайнить если останется время

### Нефункциональные требования(~3 минуты)

Сколько чего: число пользователей, публикаций, получений данных, событий и тд

DAU/MAU - daily/monthly active users
Число запрос на чтение/запись
Latency
Определить приоритет из CAP-теоремы

### Оценка(~3 минуты)

Нужно оценить в приблизительных цыфрах:
- Траффик(rps)
- Храналище, накинуть примерную схему данных
- Пропускную способность

Пример
```
DAU=1кк в день=10^6
Получение постов в день(NR)=5 на юзера
Публикация постов(NW)=100к в день=10^5

86400(SiD)- число секунд в сутках, можно округлить до 100000(10^5) чтобы быстрее считать

Traffic
Чтение: DAU * NR / SiD=10^6*5/10^5= ~50
Запись: NW / SiD=10^5/10^5= ~1
Чтение/запись: 50/1 - влияет на выбор храналища

Storage
100kb * NW = 10^5 * 10^5 = 10^10bytes = 10^10/10^9=10Gbytes
10Gb per day
300Gb per month
```

Тут нужно прийти к ответу, нужна распределенная система или нет

### High-level design(~8 минут)

Накинуть ручки АПИ, примерные параметры запросов

Дизайн можно начать с такой схемы

```
                                  /--> Read API
                                 /
Load Balancer --> API Gateway --                   ----> DB
                                 \
                                  \--> Write API
```

### Low-level design(~15 минут)

В качестве совета - начать с выбора храналища. БД разделены на некоторые типы например B-Tree/LSM-Tree, или какому-то другому признаку:

- Key Value: Redis
- RDBMS: MySQL, PSQL
- Document based: MongoDB, DynamoDB
- Wide Column: Cassandra
- Column based: Clickhouse
- Time series: InfluxDB
- SQL, NoSQL: Cocroach
- NewSQL, ACID: ?

Нужен ли SQL, нужна ли схема данных?

### Погружение(~10 минут)

Углубление в конкретные компоненты, что будет в случае отказа?

### Заключение(~3 минуы)

Еще раз проговорить всю схему

# Компоненты

## Load Balancer

Балансировка может осуществляться на разных уровнях:
- Сетевом
- Транспортном
- Прикладном

#### На сетевом

Нужно сделать так, чтобы за один IP отвечал конкретный узел.

- DNS-балансировка. На одно доменное имя будет выделен пул IP-адресов. Сервер на который будет отправлен запрос будет определяться алгоритмом Round Robin(о нем ниже)
- Построение NLB-кластера. Сервера объединяются в кластер, состоящий из входных и вычислительных узлов. Балансировка будет осуществляться по спец.алгоритму. В основном используется мелкософтом
- По IP с использование доп. маршрутизатора.
- Балансировка по территориальному признаку.

#### На транспортном

Клиент обращается к балансировщику и тот отправляет его на нужный сервер. Довольно сложно отличить от балансировки на сетевом уровне.
Из особенностей: на сетевом уровне балансировщик не работает с пользовательской сессией, а просто решает на какой сервер передавать пакеты. На транспортном уровне общение с клиентом замыкается на балансировщик и он выступает как прокси.

Как пример HAProxy

#### На прикладном

Балансировщик на прикладном режиме работает как "умный" прокси. То есть он анализирует клиентский запрос и перенаправляет на нужный сервер.

Как пример это upstream nginx или pgpool

### Алгоритмы

Есть много разных алгоритмов балансировки, выбирая какой-то из них нужно руководствоваться целью которую мы хотим достичь.
Какие могут быть цели:

- Справедливость. Нужно гарантировать, что на каждый запрос выделяется системный ресурс и нет ситуации, что один запрос обрабатывается а другие ждут
- Эффективность. Все серверы должны быть заняты на равномерно
- Сокращение времени выполнения запроса(execution)
- Сокращение времени задержки(latency)

Также важные свйоства балансировщика:

- Предсказыемость
- Равномерная загрузка
- Масштабируемость

#### Round Robin

Алгоритм перебора по кругу. То есть первый запрос отдается одному серверу, второй другому и тд

Наиболее распростараненный пример перебирать по кругу dns записи.

Достоинства:
- Можно использовать для глобальной и локальной балансировки
- Низкая стоимость решения, просто добавляем запись в dns

Недостатки:
- Желательно иметь серевера с одинковым набором ресурсов
- Никак не учитывает реальную нагрузку

#### Weighted Round Robin

Улучшение Round Robin. Тут каждому серверу добавляется вес в соответствии с производительностью

#### Least Connections

Алгоритм учитывает колличество текущих соединений на текущий момент. Новый запрос распределяется на сервер с нименьшим числом соединений

#### Destination Hash Scheduling

Используется для работы с кластером кэширующих прокси-серверов. Сервер выбирается из статической таблицы по IP-адресу получателя

#### Source Hash Scheduling

Используется для работы с кластером кэширующих прокси-серверов. Сервер выбирается из статической таблицы по IP-адресу отправителя

#### Sticky Sessions

Запросы распределяютс по серверам на основе IP клиента. Если один из серверов вышел из строя, запрос будет перенаправлен на другой сервер

Проблемы могут возникнуть если используется динамический IP


## Rate limiter

### Fixed Window

Алгоритм использует фиксированное временное окно(например 1 секунда). Каждый запрос увеличивает счетчик для этого окна, если погор превышен запрос отбрасывается.

Проблемой является всплеска запросов на границе окна

### Token bucket

Есть бакет, который пополняется токенами на запросы через какие-то промежутки времени. Если токенов в бакете не осталось, запрос отбрасывается

### Leaky Bucket

Обратный Token bucket. Бакет заполняется запросами, если бакет переполнен, запрос не проходит

### Sliding Log

Похож на алгоритм с окном, но тут мы ослеживаем время запросов и пишем их лог в пределах отслеживаемого окна. Записи за пределами окна удаляются, а если число запросов за нужный период превышено - запрос не проходит

### Sliding Window

Гибрид между Fixed Window и Sliding Log. Мы отслеживаем счетчик для каждого окна, а затем учитываем взвещенное значение частоты запросов предыдущего окна на основе текущей временной метки чтобы сгладить всплески трафика.

## Cache

Кэш - это память с большой скоростю доступа, нужная для уменьшения времения доступа к данным.

Зачем нужно:
- Сокращение времени ответа
- Снижение нагрузки на сторонии сервисы
- Переиспользованее ранее полученных или вычисленных данных
- Стабилизация работы при кратковременных отказах

### Термины

- Cache miss - промах кэша
- Cache hit - попадание кэша
- Hit ratio - процент попаданий запросов в кэш, характеристика эффективности
- Горячий ключ - ключ на который приходит много запросов
- Прогрев кэша - процесс наполнения кэша данными
- Инвалидация - удаление кэшированных данных

### Cache miss attack

Можно кэшировать не только данные, но и ошибку извлечения данных.

### Эффективность

Если CacheMissRate * CacheAccessTime > DBAccessTime кэш вреден

### Виды кэширования

#### Внутреннее кэширование

Структура данных внутри приложения.

Плюсы:
- Скорость
- Отсутствие сетевых запросов
- Нет расходов на marshal/unmarshal

Минусы:
- Горизонтальное масштабирование
- Прогрев кэша после перезагрурки

#### Внешнее кэширование

Кэш во внешнем сервисе

Плюсы:
- Большой объем данных
- Горизонтальное масштабирование
- После перезагрурки кэш не меняется
- Простой прогрев и инвализация

Минусы:
- Скорость

### Способы взаимодействия с кэшом

В основном подходы комбинируют

#### Cache aside(на стороне)

Приложение само управляет как получать/сохранять данные в кэш

#### Cache through(сквозное)

Все запросы проходят через кэш. Взаимодействие только через кэш

#### Cache ahead(опережающее)

Запрос на чтение всегда идет через кэш, периодически загружая данные из бд

### Алгоритмы вытеснения

#### RANDOM

Случайно вытесняем:)

#### FIFO

Вытесняем первого

#### LIFO

Вытесняем последнего

#### LRU

Вытесняем тот к которому дольше всего не было обращений. Более популярный

#### MRU

Вытесняем тот к которому было последнее обращение

#### LFU

Вытесняем элемент с самой низкой частотностью

### Инвалидация данных

#### По TTL

Удаляем данные по времени жизни. Если записи становятся невалидными одновременно, то источник данных может пострадать. Тут помогает jitter - случайная величина добавляемая к ttl

#### Thundering herd problem

Резкий рост нагрузки на параллельное получение данных и получение miss cache. Решение - лок по ключу

#### По событию

Оповещение кэша через брокер сообщений или какое-то другое решение

#### Версионирование кэша

В ключ кэша добавляем версию

#### Тэгирование кэша

Кэш из разных констекстов можно помечать тегом, например новости про погоду и текущий кэш о погоде

### Многомерный кэш

Кэши могут складываться в цепочку или дерево:
- Кэш браузера
- Кэш прокси-сервера
- Внутренний кэш приложения
- Внешний кэш приложения
- Кэш движка бд

## Шардирование

## Репликация

## Базы

# Проработать

TODO распростараненные примеры
- ID Generation. Snowflake
- Consistent hashing. Виртуальные шарды
- Key-value storage
- News Feeds
- Chat
- Geo Hash. Делим карту на 0 и 1, почти как по "улитке"
- Search Autocomplete System
- S3
- Cache.
- Celebrity problem
- Quadtree



