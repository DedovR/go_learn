# ACID

**A - Atomicy**(Атомарность) - гарантирует, что каждая транзакция будет выполнена полностбю или не выполнена совсем

**С - Consistency**(Согласованность) - Транзакция достигающая своего нормального заверщения и фиксирующая результат, сохраняет консистентность БД. То есть каждая успешная транзакция фиксирует только допустимые результаты, то есть соотвествуют всем ограничениям: уникальность, длина строки, зависимость внешних ключей и т.д.

**I - Isolation**(Изолированность) - Во время выполнения транзакции, параллельные транзакции не должны оказывать влияния на её результат

**D - Durability**(Надёжность) - после заверщения транзакции изменения будут записаны на диск и не потеряются отключения питания/сбоя останутся в БД

### Индексы

**Кластерный** - хранится вместе с данными, данные в таком случае будут в отсортированном порядке

**Некластерный** - хранится отдельно, содержит указатели на строки, может быть несколько

# Нормализация

Это способ организации данных, при котором нет повторяющихся данных. В процессе нормализованные данные преобразуют, чтобы они занимали меньше места а поиск по элементам был быстрым.

### Преимущества нормализации

- Уменьшение объема данных
- Упрощение поиска
- Уменьшение вероятности ошибок и аномалий

### Нормальные формы

- первая
- вторая
- третья
- нормальная форма Бойса-Кодда
- четвёртая
- пятая
- шестая

Приводить данные к нормальным формам можно только последовательно. То есть в базе данных второй нормальной формы данные по умолчанию уже должны быть нормализованы по правилам первой нормальной формы и так далее. В итоге база данных в шестой нормальной форме — идеально нормализованная.

#### Первая нормальная форма

В базе данных не должно быть дубликатов и составных данных. Например ФИО должно быть разделено на три поля. Как и адрес, например, нужно разделить на город, улицу и тд

#### Вторая нормальная форма
У каждой записи в базе данных должен быть первичный ключ. Первичный ключ — это элемент записи, который не повторяется в других записях.

#### Третья нормальная форма
В записи не должно быть столбцов с неключевыми значениями, которые зависят от других неключевых значений.

Например в таблице покупок не должно быть ФИО покупателя, должен быть его id из таблицы покупателей.

# oltp vs olap

OLTP помогает управлять транзакциями в реальном времени и обрабатывать их. OLAP использует исторические и объединенные данные из нескольких источников. OLTP использует транзакционные данные в реальном времени из одного источника. OLAP использует многомерные (в формате кубов) или реляционные базы данных.

# Управление конкернтным доступом

Это набор средств, защищающий пользователя от несогласованности данных и обеспечивающий изоляцию транзакций.

Стандарт SQL определяет 4 уровня изоляции транзакций:
- Read uncommited
- Read commited
- Repeatable read
- Serializable

Для каждого уровня есть условия не допустимые для него
- "Грязное чтение"- транзакция читает данные, записанные параллельной незавершённой транзакцией
- неповторяемое чтение - транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения)
- фантомное чтение - транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия,
и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время
- аномалия сериализации - результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди

### Пример

```sql
begin isolation level repeatable read;
UPDATE users
SET name = 'Rostikk'
WHERE id=1;
commit;
```

# SQL

## Порядок выполнения запросов
- FROM
- JOIN
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY
- LIMIT

## UPSERT

```sql
INSERT INTO users(id, name)
VALUES (1, 'Rostikk')
ON CONFLICT (id)
DO UPDATE
SET name=EXCLUDED.name;
```

## Кортеж

Это упорядоченный список элементов, где каждый элемент представляет определенный атрибут данных. В csv например разделенный запятой строка это кортеж

```sql
select *
from users
where (id, name) = (2, 'Ivan');
```

## Пагинация

limit-offset
```sql
select *
from users
order by id
limit 2
offset 1
```

В приложении можно запомнить последний id и от него брать limit

курсор?

Строки, пропускаемые согласно предложению OFFSET, тем не менее должны вычисляться на сервере. Таким образом, при больших значениях OFFSET работает неэффективно.


## Common Table Expressions, CTE

WITH предоставляет способ записывать дополнительные операторы для применения в больших запросах.

```sql
WITH regional_sales AS (
 SELECT region, SUM(amount) AS total_sales
 FROM orders
 GROUP BY region
), top_regions AS (
 SELECT region
 FROM regional_sales
 WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
 product,
 SUM(quantity) AS product_units,
 SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
```

## FILTER

Ещё один способ выбрать строки, которые входят в составные вычисления, — это использовать
предложение FILTER, которое указывается для каждой агрегатной функции:
```sql
SELECT city, count(*) FILTER (WHERE temp_lo < 45), max(temp_lo)
 FROM weather
 GROUP BY city;
```

## LATERAL

Перед подзапросами в предложении FROM можно добавить ключевое слово LATERAL. Это позволит
ссылаться в них на столбцы предшествующих элементов списка FROM. (Без LATERAL каждый подзапрос выполняется независимо и поэтому не может обращаться к другим элементам FROM.)




### PSQL vs MySQL
| PSQL | MySQL(InnoDB) |
|------|-------|
| Каждый коннект - это новый процесс | Каждый коннект это новый поток |
| Один движек храения данных | Несколько движков хранения данных с общим интерфейсом|
| Богатая статистика(statistics collector) по колонкам в запросах, что позволяет планировщику лучше составлять план: размер таблиц, страниц, статистика распределения пар значений | Относительно небольшой набор: размер кластерного индекса, число строк, распределение значений в т.ч. null |
| MVCC реализован через версии страниц таблицы(heap), в качестве версии используется строка и min/max номера транзакций которые затрагивают определенные строки. После всех манипуляций, старые значения(версии) удаляет автовакуум. Из-за вакуума может проседать производительность из-за сканирования неактуальных данных | Актуальные данные хранятся на диске, изменеия попадают в UNDO Storage. В случае роллбека нужно будет накатить изменения из UNDO Storage на диск. Хранит меньше мусора |
| Все индексы некластерные. Есть поддержка составных, частичных, функциональных. Есть B-Tree, Hash, GiST, SP-GiST, GIN, BRIN. Какой индекс использовать решает планировщик, явно указать нельзя | Первичный ключ является кластерным, остальные некластерные. Есть только В+ Tree, хеш-индекс используется в неявном виде. В запросе можно указать(hint) использовать индекс или нет |

**MariaDB** – это модифицированная версия MySQL. Сервис MariaDB был создан первоначальной командой разработчиков MySQL из-за проблем с лицензированием и распространением после того, как базу данных MySQL приобрела корпорация Oracle. С момента приобретения MySQL и MariaDB развивались по-разному. Несмотря на это, MariaDB использует файлы данных и определений таблиц MySQL, а также идентичные клиентские протоколы, клиентские API, порты и сокеты. Благодаря этому пользователи MySQL могут без проблем переходить на MariaDB. Немного быстрее MySQL, может поддерживать большое число подключений.

## PSQL

Свободная объектно-реляционная система управления базами данных

### Индексы

- B-Tree
- Hash
- GiST
- SP-GiST
- GIN
- BRIN

### WAL(Write Ahead Log)

Журнал пердзаписи - метод обеспечения целостности данных. Сначала данные о транзакции заносятся в WAL а уже после выполняются в таблицах. С WAL нет необходимости записывать данные на диск, так как в результате сбоя мы сможем восстонавить их из журнала. То есть WAL снижает число записей на диск, так как записи проходят пачками

Также за счет WAL возможно резервное копирование и восстонавлени

#### Ассинхронное подтверждение транзакций

В таком режими, бд сообщает об успешном завершении транзакции до фактической записи WAL на диск. Такой подход может привести к потере данных и не может использоваться в ситуациях где нужны гарантии записи. Но может ускорить запись мелких транзакций например логов. Режим можно установить для каждой транзакции

```sql
SET LOCAL synchronous_commit = 'off';
```

#### Найстройки WAL

Контрольные точки - это точки в последовательности транзакций, в которых гарантируется, что файлы и данные с индексами были обновлены всей информацией записанной перед контрольной точкой. Отдельный серверный процесс выполняет контрольные точки с заданной частотой:
- checkpoint_timeout - по времени(5 минут по дефолту)
- max_wal_size - по размеру wal(1Гб по дефолту)
- SQL-командой `CHECKPOINT`

При создании контрольной точки происходит запись "грязных" страниц на диск

WAL разбит на сегменты, когда старые сегменты становятся не нужны они удаляются или переиспользуются

#### Внутренне устройство WAL

WAL включается автоматически.
Записи WAL добавляются в файлы WAL по мере поступления. Позицию добавления определяет LSN - смещение в байтах внутри WAL. Файлы WAL хранятся в каталоге pg_wal, размер их обычно 16Мб, размер можно изменить с помощью --wal-segsize.
Имеет смысл хранить файлы вот на другом диск, где хранятся данные и создать симлинк.
После выполнения контрольный точки и сброса WAL точки сохраняются в файл pg_control

### Репликация

Так как нет единого решения проблемы синхронизации данны между серверами предлагается несколько решений.

Резервный сервер, к которому нельзя подключаться до тех пор, пока он не будет повышен до главного, называется сервером тёплого резерва, а тот, который может принимать соединения и обрабатывать запросы только на чтение, называется сервером горячего резерва.

- Отказоустйочивость на разделяемых дисках. После отказа БД, резервный сервер запустится с разделяемого диска. Позволяет быстро подняться после сбоя
- Репликация на уровне файловой системы. Копия главной БД должна копироваться на резервный сервер
- Трансляция WAL. Резервный сервер получается данные из WAL и почти всегда актуален. Если главный сервер упал, может быстро занять его роль
- Логическая репликация. Механизм логической репликации формирует поток данных на основе обработки WAL. Позволяет переносить изменения данных на уровень таблиц. Не обязательно должен быть главный/второстепенный сервер. Данные двигаются в разных направлениях
- Репликация мастер/слейв на основе триггеров. Запросы изменяющие данные передаются на мастер, а он после записи передает данные на реплики
- Репликация SQL в среднем слое(middleware). Middleware перехватывает запрос, все изменяющие запросы отправляет на все сервера. Сервера работают независимо. А читающие запросы выполняются на одном. Функции подобные random(),
CURRENT_TIMESTAMP и последовательности могут получить различные значения на разных серверах.
- Ассинхронная репликация с несколькими ведущими. Может использоваться если среверы находятся в разных сетях или с низкоскоростным каналом. Сервера периодически связываются с другими. В процессе могут возникать конфликты которые нужно решать пользователю или автоматически.
- Синхронная репликация с несколькими ведущими. Каждый сервер может принимать запросы на запись и пересылать их другим. Примеров нет, но так как psql имеет двухфазное подтверждение транзакции такое можно релизовать в приложении

#### Трансляция журналов

Поддерживается psql. Можно:
- Передавить файлы
- Сделать потоковую репликацию

Каскадная репликация - это когда реплики проксируют поток на другие реплики
Синхронная репликация. По умолчанию она ассинхронная, но можно включить синхронную что повысит гарантии, что транзакции были переданым реплике(ам)


# MongoDB

Документоориентировання БД, документы хранятся в формате json. Данные хранятся в виде коллекций и документов в них.

Не имеет четкой структуры. Команды вызываются как вызовы функций с параметрами. Есть уникальные поля ObjectId('_id'). По ним можно связывать коллекции. На него хорошо ложится ORM(Object-relational mapping).
