# ACID

**A - Atomicy**(Атомарность) - гарантирует, что каждая транзакция будет выполнена полностбю или не выполнена совсем

**С - Consistency**(Согласованность) - Транзакция достигающая своего нормального заверщения и фиксирующая результат, сохраняет консистентность БД. То есть каждая успешная транзакция фиксирует только допустимые результаты, то есть соотвествуют всем ограничениям: уникальность, длина строки, зависимость внешних ключей и т.д.

**I - Isolation**(Изолированность) - Во время выполнения транзакции, параллельные транзакции не должны оказывать влияния на её результат

**D - Durability**(Надёжность) - после заверщения транзакции изменения будут записаны на диск и не потеряются отключения питания/сбоя останутся в БД

### Индексы

**Кластерный** - хранится вместе с данными, данные в таком случае будут в отсортированном порядке

**Некластерный** - хранится отдельно, содержит указатели на строки, может быть несколько

# Нормализация

ТУДУ

# Управление конкернтным доступом

Это набор средств, защищающий пользователя от несогласованности данных и обеспечивающий изоляцию транзакций.

Стандарт SQL определяет 4 уровня изоляции транзакций:
- Read uncommited
- Read commited
- Repeatable read
- Serializable

Для каждого уровня есть условия не допустимые для него
- "Грязное чтение"- транзакция читает данные, записанные параллельной незавершённой транзакцией
- неповторяемое чтение - транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения)
- фантомное чтение - транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия,
и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время
- аномалия сериализации - результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди

### Пример

```sql
begin isolation level repeatable read;
UPDATE users
SET name = 'Rostikk'
WHERE id=1;
commit;
```

## Порядок выполнения запросов
- FROM
- JOIN
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY
- LIMIT

## UPSERT

```sql
INSERT INTO users(id, name)
VALUES (1, 'Rostikk')
ON CONFLICT (id)
DO UPDATE
SET name=EXCLUDED.name;
```

## Кортеж

Это упорядоченный список элементов, где каждый элемент представляет определенный атрибут данных. В csv например разделенный запятой строка это кортеж

```sql
select *
from users
where (id, name) = (2, 'Ivan');
```

## Пагинация

limit-offset
```sql
select *
from users
order by id
limit 2
offset 1
```

В приложении можно запомнить последний id и от него брать limit

курсор?

Строки, пропускаемые согласно предложению OFFSET, тем не менее должны вычисляться на сервере. Таким образом, при больших значениях OFFSET работает неэффективно.


## Common Table Expressions, CTE

WITH предоставляет способ записывать дополнительные операторы для применения в больших запросах.

```sql
WITH regional_sales AS (
 SELECT region, SUM(amount) AS total_sales
 FROM orders
 GROUP BY region
), top_regions AS (
 SELECT region
 FROM regional_sales
 WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
 product,
 SUM(quantity) AS product_units,
 SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
```


### PSQL vs MySQL
| PSQL | MySQL(InnoDB) |
|------|-------|
| Каждый коннект - это новый процесс | Каждый коннект это новый поток |
| Один движек храения данных | Несколько движков хранения данных с общим интерфейсом|
| Богатая статистика(statistics collector) по колонкам в запросах, что позволяет планировщику лучше составлять план: размер таблиц, страниц, статистика распределения пар значений | Относительно небольшой набор: размер кластерного индекса, число строк, распределение значений в т.ч. null |
| MVCC реализован через версии страниц таблицы(heap), в качестве версии используется строка и min/max номера транзакций которые затрагивают определенные строки. После всех манипуляций, старые значения(версии) удаляет автовакуум. Из-за вакуума может проседать производительность из-за сканирования неактуальных данных | Актуальные данные хранятся на диске, изменеия попадают в UNDO Storage. В случае роллбека нужно будет накатить изменения из UNDO Storage на диск. Хранит меньше мусора |
| Все индексы некластерные. Есть поддержка составных, частичных, функциональных. Есть B-Tree, Hash, GiST, SP-GiST, GIN, BRIN. Какой индекс использовать решает планировщик, явно указать нельзя | Первичный ключ является кластерным, остальные некластерные. Есть только В+ Tree, хеш-индекс используется в неявном виде. В запросе можно указать(hint) использовать индекс или нет |

**MariaDB** – это модифицированная версия MySQL. Сервис MariaDB был создан первоначальной командой разработчиков MySQL из-за проблем с лицензированием и распространением после того, как базу данных MySQL приобрела корпорация Oracle. С момента приобретения MySQL и MariaDB развивались по-разному. Несмотря на это, MariaDB использует файлы данных и определений таблиц MySQL, а также идентичные клиентские протоколы, клиентские API, порты и сокеты. Благодаря этому пользователи MySQL могут без проблем переходить на MariaDB. Немного быстрее MySQL, может поддерживать большое число подключений.

# MongoDB

Документоориентировання БД, документы хранятся в формате json. Данные хранятся в виде коллекций и документов в них.

Не имеет четкой структуры. Команды вызываются как вызовы функций с параметрами. Есть уникальные поля ObjectId('_id'). По ним можно связывать коллекции. На него хорошо ложится ORM(Object-relational mapping).
