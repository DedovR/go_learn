# defer, panic, recovery
`defer` используется для выполнения кода после выполнения функции. Используется для упрощения функций, которые занимаются освобождением ресурсов.
- Аргументы вычисляются на момент вычисления `defer`. Может менять именованный выходной параметр
```go
func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}
// 0
```
- Выполняется по принципу LIFO
```go
func b() {
    for i := 0; i < 4; i++ {
        defer fmt.Print(i)
    }
}
// 3210
```
- Отложенные функции могут читать значения возвращаемые значения объемлющей функции
```go
func c() (i int) {
    defer func() { i++ }()
    return 1
}
// 2
```

`panic` - встроенная функция, которая прерывает обычный поток выполнения.
Когда функция Ф() вызывает панику, все действия Ф() отсанавливаются, выполняются все `defer`. Далее по стеку передается паника, пока не дойдет вниз по всему стеку. После чего программа аварийно завершается. Вызвать можно прямо через `panic()` или в случае ошибки в рантайме. Паника в горутине вызовет панику вплоть до планировщика, но `defer` вызывающей функции её не перехватит. Не обработанная паника в горутине завершит аварийно всё приложение.

`recovery` - функция которая восстанавливает контроль над паникующей процедурой. Полезна только внутри defer, во время нормального выполнения возвращает nil и больше не имеет других эффектов.
```go
func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    panic()
}
```



# switch
```go
switch os := runtime.GOOS; os {
case "darwin":
  fmt.Println("OS X.")
case "linux":
  fmt.Println("Linux.")
default:
  fmt.Printf("%s.\n", os)
}
```
Пустой с условием
```go
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```

# Типы
- Целочисленные: byte, int, uint, rune(alias int32)
- С плавающей запятой: float32, float64
- Комплексные: complex64, complex128
- Булевы: bool
- Строки: string

```go
// Получаем тип через .(type)
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

// Через рефлексию
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())
```

# Руны
Так как в го строка это массив байт, то символы unicode могут занимать больше чем байт и для них используются руны(rune) - алиас на int32.

# Array & Slice
Массив - коллекция элементов одного типа, фиксированной длины. Массив это примитив, по этому он будет копироваться в функцию
```go
a := [3]int{}
b := [2]int{}
// (a) [2]int и (b) [3]int - разные типы

a := [...]int{1, 2, 3} // [3]int
```

Срезы - массивы у которых может увеличиваться длина
```go
// С помощью make
var foo []byte
s = make([]byte, 5, 5)

// С помощью shorthand syntax
bar := []byte{}
```
Срез состоит из ссылки на массив, len, cap. По этому в функцию передается ссылка

append() - добавление эелемента в слайс. Если выйти за границу capacity срез будет ссылаться уже на другую область памяти
Нельзя брать ссылки на элементы, так как массив может переехать при расширении

# Map
Хеш-таблица, в качестве ключа должен быть тип comparable. Можно использовать даже структуру у которой все поля comparable.

```go
mp := map[int]string{
	1:"a",
}
if _, ok := mp[2]; !ok {
	fmt.Println("Не найдено") // Не найдено
}
```
Под капотом имеет хеш-функцию для формирования ключа и бакеты размером 8. В среднем в бакете хранится 6,5 элементов, если больше происходит эвакуация. При эвакуации число бакетов растет вдвое. Перенос данных происходит постепенно, при удалении или добавлении нового элемента.
Мапа хранит ссылку на структура hmap(похоже на слайс), т.е. при передаче в функцию всё равно передается указатель.

# Interface

Это тип, который определяет сигнатуры методов, но не содержит их реализацию

Структура iface
```golang
type iface struct {
	tab  *itab          // это указатель на Interface Table или itable - структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
	data unsafe.Pointer // Это указатель на конкретные данные или значение, которые реализуют интерфейс. Использование unsafe.Pointer позволяет интерфейсу ссылаться на данные произвольного типа, сохраняя при этом информацию о том, как к ним обращаться через itab.
}
```
Пустой интерфейс ничего не реализует

Nil-интерфейс
```golang
func main() {
	var i interface{}
	// type == nil, value == nil
	// поэтому i == nil
	fmt.Println(i == nil) // true

	var d *Dog
	fmt.Println(d == nil) // true

	i = d
	// type == *Dog, value == nil
	// поскольку type != nil, то i != nil
	fmt.Println(i == nil) // false
}
```
# Контекст

Позволяет передавать данные в программу в каком-то контексте:)

Можно создать разные контексты:
- context.Background() - пустой контекст высокого уровня, где-то около мейна. Из него можно получать другие контексты
- context.TODO() - также пустой контекст высокого уровня, но нет уверенности что его нужно использовать
- context.WithValue() - эта функция принимает контекст и возвращает производный от него контекст, в котором значение val связано с key и проходит через всё контекстное дерево
- context.WithCancel() - вернет контекст и функцию отмены
- context.WithDeadline() - эта функция возвращает производный контекст от своего родителя, который отменяется после дедлайна или вызова функции отмены.
- context.WithTimeout() - Эта функция похожа на context.WithDeadline. Разница в том, что в качестве входных данных используется длительность времени



# Конкурентность

## Планировщик

При запуске программы го ей присваивается логический процессор Р на каждое виртуальное ядро машины. Каждому Р назначется поток ОС М. Горутины G выполняются на М. Это похоже на потоки ОС, но внутри одного потока

- G - горутина, егковесный поток в рантайме го. Имеет стек 2К.
- M - машина, поток ОС
- P - процессор планировщика. Это условный контекс, который объединяет поток ОС и очередь горутин. Число процессоров берется из GOMAXPROCS

Состояние горутин:
- Waiting - ожидает чего-то: ответа от ОС, системный вызовы, освобождение ресурсов(от мьютекса, например) и т.д.
- Runnable - ждет выполнения на М
- Running - помещена в М и выполняется

### Переключения контекста (Context Switching).
В сравнении с переключением контекста OS, переключение контекста у планировщика GO - более легковесная операция: ~200 наносекунд, при которых мы теряем ~2 400 операций. То есть примерно в пять раз меньше.

### Очереди горутин

В планировщике Go есть две разные очереди: глобальная очередь(Global Run Queue - GRQ) и локальная очередь(Local Run Queue - LRQ).

Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.
GRQ предназначен для горутин, которые еще не были назначены для какого-либо P. Существует процесс перемещения горутин из GRQ в LRQ.

#### Кража горутин

Если процессор Р остался без горутин он может украсть горутину у другого процессора. Происходит это 1/61 тик планировщика

```golang
runtime.schedule() {
    // only 1/61 of the time, check the global runnable queue for a G.
    // if not found, check the local queue.
    // if not found,
    //     try to steal from other Ps.
    //     if not, check the global runnable queue.
    //     if not found, poll network.
}
```

#### Многозадачность

В го с 1.14 поддерживается вытесняющая многозадачность. Контекст переключается, если:
- Ожидается I/O
- Syscall
- Операция синхронизации. Например горутина ожидает разблокировки ресурсов от другой горутины
- runtime.Gosched() - можно явно указать
- Долгие вычисления без прерываний ~10мс
- Вызов функций, поддерживающих переключение контекста: Некоторые функции, такие как time.Sleep() или блокировка на канале, также могут привести к переключению контекста.

### Каналы
Канал — это объект связи, с помощью которого горутины обмениваются данными. Могут быть с буфером.
- Закрывать должен писатель.
- Писать в закрытый канал = паника
- При чтении из закрытого канала получим нудевое значени + флаг
```go
// Создать канал
ch := make(chan int)
// Запись в канал
ch <- 1
// Чтение из канала
a <- ch
// Закрыть канал
close(ch)
// Чтение пока канал не закроется
for val := range c {
  fmt.Println(val)
}
// Выбор между каналами
select {
case res := <-ch1:
  fmt.Println("Response from chan1")
case res := <-ch2:
  fmt.Println("Response from chan2")
default:
}
```

### Синхронизация
Атомики - используют Compare-and-swap(Сравнение с обменом), сравнивает значение в памяти с одним из аргументов, и в случае успеха записывающая второй аргумент в память

Мьютекс - блокирует участок памяти, `Lock()/Unlock()`

Вейт-группа - используется, когда нужно ждать окончания нескольких горутин

Once - если нужно выполнить всего один раз за всё время

### Утечки
Могут быть из-за незакрытых каналов, файловых дескрипторов, запись в глобальные переменные.
Чтобы найти:
- Просмотреть код глазами, где не закрыты соединения, дескрипторы и т.д.
- Использовать профилировщик
- Помониторить рост числа дескрипторов `ls -la /proc/{pid}/fd`
- ИСпользовать `runtime.MemStats`

# Garbage Collector

В го это конкурентный, трехцветный, Mark and Sweep сборщик.
В трехцветном сборщике, каждый объект может быть помечен белым, черным или серым цветом. А куча(heap) рассматривается как граф связанных объектов.

В начале каждого цикла GC все объекты белые. GC проходит все корневые узлы, напрямую доступными программе: глобальные переенные и переменные в стеке и помечает их серыми.

Затем GC выбирает серый объект, делает его черным и сканирует их на наличие указателей и других объектов. Если скан находит указатель на белый он делает его серым. Этот процесс повторяется пока не останется белых объектов. После этого считается, что все белыеобъекты не достижимы и могут быть переиспользованы.

Mark and Sweep состоит из 2 фаз:

- Mark: находим и отмечаем все достижимые объекты из набора (например, в куче).

- Sweep: проходим по всем объектам в куче, затираем недостижимые и возвращаем их в пул свободной памяти.

GOGC - переменная, значение которой контролирует общий размер кучи относительно размера достижимых объектов

#### Периоды запуска GC

- периодически из потока sysmon , если прошло достаточно много времени с последнего запуска
- после выделения памяти, если выделен большой Span или не удалось выделить быстро
- при ручном вызове runtime.GC()

#### Управление

Есть только один ползунок для настройки GOGC. Его размер контролирует размер кучи относительно размера достижимых объектов. То есть дейлотный 100 означается, что размер кучи на 100% больше чем размер достижимых объектов после последнего цикла GC, то есть в два раза больше. Если мы хотим уменьшить время работы GC нужно увеличить GOGC.
