# Deadlock
Взаимная блокировка. Ситуация при которой одному процессу требуется ресурс захваченный первым процессом, а первый процесс ожидает ресурс захваченный вторым

# Race conditions
Ситуация при которой несколько ассинхронных потоков пытаются одновременно получить доступ к ресурсу без синхронизации

# Идемпотентность
Свойство объекта или операции при повтороном применении у объекту давать тот же результат

# SOLID

### S – Single Responsibility (Принцип единственной ответственности)
Каждый класс(структура) должен отвечать только за одну операцию.

### O — Open-Closed (Принцип открытости-закрытости)
Классы должны быть открыты для расширения но закрыты для модификации.

### L — Liskov Substitution (Принцип подстановки Барбары Лисков)
Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

Класс потомок должен уметь выполнять теже функции, что и родитель

### I — Interface Segregation (Принцип разделения интерфейсов)
Не следует ставить клиент в зависимость от методов, которые он не использует.

Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

### D — Dependency Inversion (Принцип инверсии зависимостей)
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

# Protobuf

Это формат сериализации данных, разработанный компанией Google. Он эффективно и компактно хранит структурированные данные в двоичной форме, что позволяет быстрее передавать их по сети.


# gRPC

gRPC — это фреймворк RPC от Google. Использует бинарный формат передачи данных и HTTP 2.0

Для обратной совместимости создаем новую версию апи

# Планировщик ОС

Планировщик отвечает за то, чтобы ядра процессора не простаивали если потоки готовые к выполнению.

Каждая запущенная программа порождает процесс. У каждого процесса есть начальный поток. Потоки имеют возможность создавать больше потоков. Потоки могут работать независимо друг от друга и планирование происходит на уровне потоков а не процессов. Поток выполняет последовательность инструкций.

Потоки могут быть в трех состояниях:
- Ожидание - поток останволен и ожидает чего-то для продолжения выполнения
- Готовность - поток требует машинного времени для выполнения инструкций
- Выполнение - поток размещен на ядре и выполняет инсрукции

### Типы работ

Поток может выполнять два типа работ:
- CPU-Bound - вычисления на процессоре
- IO-Bound - работа которая заставляет переходить поток в состояние ожидания: запрос доступа ресурса по сети, системный вызов, ожидание мьютекса, доступ к БД и тд

### Переключение контекста

Планировщик ОС работает в вытеснящем режиме. Это значит, что последовательность выполнения потоков непредсказуема.

Процесс прекращения выполнения потока с сохранением всей инфы о его состоянии, необходимой для продолжения выполнения и загрузка нового состояния прерваной ранее задачи называется Переключение Контекста(ПК).

ПК считается дорогостоящей операцией, может занимать 12-18к(1000-1500нс) инструкций. То есть машинное время насходуется на ПК вместо полезной работы. Если программа связана с IO-Bound, то ПК позитивно будет влять на производительность. А если с CPU-Bound это сыграет негативным образом.

### Кэш процессора

Доступ к RAM имеет большую задержку 100-300 тактов. Доступ к данным из кэша обходится намного дешевле 3-40 тактов. Производительность многопотоных приложений зависит от того насколько эффективно можно передавать данные в процессор.

Обмен данными между процессором и основной памятью происходит по средствам строк кэша - 64-байтовый фрагмент памяти. Каждое ядро получает копия строки кэша, в которой оно нуждается. По этому мутации памяти в многопоточных приложениях могут создавать проблемы производительности. Но если несколько потоков работают параллельно и обращаются к одному участку памяти или даже рядом, то получать они будут данные из одной строки кэша. Любой поток на любом ядре получит свою копию этой же строки кэша.
Если поток вносит изменения в кэш, то строки на других ядрах будут помечены как "грязные" и при попытке получить данные нужно будет обращение в основную память. На машинках с малым число ядер это не проблема, но например на 32ядерном процессоре это уже станет проблемой. Проблема эта называется **когерентность кэша**. Для многопоточных приложений это проблема должна быть принята во внимание.
